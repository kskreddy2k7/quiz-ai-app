from fastapi import APIRouter, HTTPException, BackgroundTasks
from fastapi.responses import FileResponse
from api.models import PresentationRequest
from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.dml.color import RGBColor
from pptx.enum.shapes import MSO_SHAPE
from pptx.enum.text import PP_ALIGN
from fpdf import FPDF
from docx import Document
from docx.shared import Pt as DocxPt, RGBColor as DocxRGB
from docx.enum.text import WD_ALIGN_PARAGRAPH
from services.ai_service import ai_service
import os
import uuid
import traceback

router = APIRouter(prefix="/presentation", tags=["Smart Notes"])

def delete_file(path: str):
    if os.path.exists(path):
        try:
            os.remove(path)
        except:
            pass

# --- 1. PDF GENERATOR ---
class NotesPDF(FPDF):
    def header(self):
        self.set_font('Arial', 'B', 12)
        self.cell(0, 10, 'Smart Notes by QuizAI', 0, 1, 'R')
        self.ln(5)

    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.cell(0, 10, f'Page {self.page_no()}', 0, 0, 'C')

def generate_pdf_notes(content, topic):
    pdf = NotesPDF()
    pdf.add_page()
    pdf.set_auto_page_break(auto=True, margin=15)
    
    # Title
    pdf.set_font('Arial', 'B', 24)
    pdf.set_text_color(33, 33, 33)
    pdf.multi_cell(0, 10, topic.upper(), align='C')
    pdf.ln(10)
    
    # Content Loop
    slides = content.get("slides", [])
    for slide in slides:
        title = slide.get("title", "Section")
        points = slide.get("content", [])
        
        # Section Title
        pdf.set_font('Arial', 'B', 16)
        pdf.set_text_color(108, 74, 227) # Purple
        pdf.cell(0, 10, title, 0, 1)
        pdf.ln(2)
        
        # Content
        pdf.set_font('Arial', '', 12)
        pdf.set_text_color(50, 50, 50)
        for point in points:
            # Bullet point
            pdf.multi_cell(0, 8, f"{chr(149)} {point}")
        pdf.ln(5)
        
    filename = f"notes_{uuid.uuid4().hex}.pdf"
    path = os.path.join("static", "temp", filename)
    os.makedirs(os.path.dirname(path), exist_ok=True)
    pdf.output(path)
    return path

# --- 2. DOCX GENERATOR ---
def generate_docx_notes(content, topic):
    doc = Document()
    
    # Title
    title = doc.add_heading(topic, 0)
    title.alignment = WD_ALIGN_PARAGRAPH.CENTER
    
    slides = content.get("slides", [])
    for slide in slides:
        title_text = slide.get("title", "Section")
        points = slide.get("content", [])
        
        # Section Header
        h = doc.add_heading(title_text, level=1)
        
        # Content
        for point in points:
            p = doc.add_paragraph(point, style='List Bullet')
            
    filename = f"notes_{uuid.uuid4().hex}.docx"
    path = os.path.join("static", "temp", filename)
    os.makedirs(os.path.dirname(path), exist_ok=True)
    doc.save(path)
    return path

# --- 3. PPTX GENERATOR (Existing Logic) ---
def generate_pptx_slides(content, req):
    prs = Presentation()
    
    # Theme Setup
    theme_map = {
        "Modern": {"title_color": RGBColor(31, 73, 125), "accent": RGBColor(236, 72, 153)},
        "Creative": {"title_color": RGBColor(255, 105, 180), "accent": RGBColor(138, 43, 226)},
        "Professional": {"title_color": RGBColor(0, 51, 102), "accent": RGBColor(0, 102, 204)},
        "Dark": {"title_color": RGBColor(80, 80, 80), "accent": RGBColor(0, 255, 127)},
        "Gradient": {"title_color": RGBColor(112, 56, 246), "accent": RGBColor(255, 126, 95)},
    }
    selected_theme = theme_map.get(req.theme) or theme_map["Modern"]
    theme_font = req.font_style if req.font_style in ["Arial", "Calibri"] else "Arial" # Basic font fallback
    
    def style_text(text_frame, font_name, size, bold=False, color=None):
        for p in text_frame.paragraphs:
            p.font.name = font_name
            p.font.size = size
            if bold: p.font.bold = True
            if color: p.font.color.rgb = color

    # Title Slide
    slide = prs.slides.add_slide(prs.slide_layouts[0])
    slide.shapes.title.text = req.topic
    slide.placeholders[1].text = "Generated by Smart Notes AI"
    style_text(slide.shapes.title.text_frame, theme_font, Pt(54), True, selected_theme["title_color"])

    # Loop Slides
    for slide_data in content.get("slides", []):
        slide = prs.slides.add_slide(prs.slide_layouts[1])
        slide.shapes.title.text = slide_data.get("title", "")
        style_text(slide.shapes.title.text_frame, theme_font, Pt(40), True, selected_theme["title_color"])
        
        tf = slide.placeholders[1].text_frame
        tf.clear()
        for point in slide_data.get("content", []):
            p = tf.add_paragraph()
            p.text = str(point)
            p.font.size = Pt(24)

    filename = f"notes_{uuid.uuid4().hex}.pptx"
    path = os.path.join("static", "temp", filename)
    os.makedirs(os.path.dirname(path), exist_ok=True)
    prs.save(path)
    return path


@router.post("/generate")
async def generate_notes(req: PresentationRequest, background_tasks: BackgroundTasks):
    if not ai_service.has_ai:
        raise HTTPException(status_code=400, detail="AI Service unavailable")
    
    try:
        # 1. Get Content
        content = await ai_service.generate_presentation_content(
            req.topic, req.num_slides, req.language, req.theme, req.tone
        )
        
        # 2. Generate Format
        if req.format == "pdf":
            file_path = generate_pdf_notes(content, req.topic)
            media_type = "application/pdf"
            out_name = f"{req.topic}_Notes.pdf"
        elif req.format == "docx":
            file_path = generate_docx_notes(content, req.topic)
            media_type = "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            out_name = f"{req.topic}_Notes.docx"
        else:
            file_path = generate_pptx_slides(content, req)
            media_type = "application/vnd.openxmlformats-officedocument.presentationml.presentation"
            out_name = f"{req.topic}_Slides.pptx"

        # 3. Return
        background_tasks.add_task(delete_file, file_path)
        return FileResponse(path=file_path, filename=out_name, media_type=media_type)

    except Exception as e:
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))
